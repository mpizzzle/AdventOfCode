(define (distinct elements)
  (define (count-distinct l d count)
     (cond ((null? l) count)
           ((member (car l) d)
            (count-distinct (cdr l) d count))
           (else
            (count-distinct (cdr l) (cons (car l) d) (+ 1 count)))))
  (count-distinct elements '() 0))

(define (right-fold answers policy)
  (if (not (null? answers))
    (if (not (= (string-length (car answers)) 0))
      (append (policy (car answers)) (right-fold (cdr answers) policy))
      (list (right-fold (cdr answers) policy)))
    '()))

(define (unfold answers)
  (if (not (null? answers))
    (let ((tail (reverse answers)))
      (if (not (pair? (car tail)))
        (list tail)
        (cons (cdr tail) (unfold (car tail)))
      ))
    '()))

(load "read_lines.scm")
(define answers (read-lines "files/6.txt" (lambda (x) x)))

(display (apply + (map distinct (unfold (right-fold answers string->list))))) (newline)
(display (apply + (map distinct (map (lambda (sets) (if (pair? (car sets)) (apply lset-intersection eqv? sets) '()))
                                     (unfold (right-fold answers (lambda (x) (list (string->list x))))))))) (newline)
